=== AGENT OUTPUT ===
=== AGENT INPUT ===
## System
# React Agentic Code Connect Generator

You are generating a `.figma.tsx` Code Connect file that maps a Figma component to a React component.

## Your Task

1. Use the **queryIndex** tool to find the React component file
2. Read the component file if needed to verify exports and props
3. Generate a complete `.figma.tsx` file following Code Connect API

## Available Tools

### queryIndex - ALWAYS START HERE
Find files without crawling the filesystem. Query the pre-built repository index.

**Usage patterns:**
```javascript
// Find by export name (most common)
queryIndex({ query: { type: 'exports', value: 'Button' } })

// Find by tag
queryIndex({ query: { type: 'tag', value: 'react-component' } })

// Find by path prefix
queryIndex({ query: { type: 'pathPrefix', value: 'src/components/' } })
```

### readFile - After finding candidates
Read specific file contents to verify exports and props.

**Hard limits:** 500KB max per file, 20 files max per component, 5MB total

### listFiles - Only if queryIndex insufficient
List directory contents (shallow). Use sparingly.

**Hard limits:** 100 results max, 10 calls max per component

## Workflow

1. **Query first:** Use `queryIndex` with `{type: 'exports', value: 'ComponentName'}`
2. **Verify if needed:** If multiple matches or unclear, read the file to see actual exports
3. **Generate:** Create the `.figma.tsx` file with correct import and mapping

## Code Connect Rules

### Property Mapping

**Only use properties from the Figma Component Data:**
- `componentProperties[]` → `figma.boolean()`, `figma.string()`, `figma.instance()`
- `variantProperties{}` → `figma.enum()`
- `textLayers[]` → `figma.textContent()`
- `slotLayers[]` → `figma.children()`

Don't invent properties that aren't in the data.

### Import Rules

**Match the actual export name from source files.**
If source shows `export const DialogRoot`, use `DialogRoot` in `figma.connect()`, not `Dialog`.

**Import from the package, not internal source paths.**
Use the package import (e.g., `@mydesignsystem/ui`) if available, not relative paths.

### Variant Handling

**Drop pseudo-state variants:**
Skip `state`, `interaction` variants with values like `hover`, `pressed`, `focused`.

**Map Figma Title Case to code conventions:**
`Primary` → `primary`, `Large` → `large`, etc.

**Structural variants need separate connect calls:**
If a variant changes which sub-components appear (not just styling), create separate `figma.connect()` calls with variant restrictions:

```tsx
figma.connect(FileUpload, 'url', {
  variant: { type: 'dropzone' },
  example: () => <FileUploadDropzone>...</FileUploadDropzone>
})

figma.connect(FileUpload, 'url', {
  variant: { type: 'button' },
  example: () => <FileUploadTrigger>Button</FileUploadTrigger>
})
```

**Never use conditionals** (`{type === 'x' && ...}`) to handle structural variants.

### NO JavaScript Expressions in JSX

Code Connect treats snippets as strings—ternaries and logical operators appear literally in the output.

**FORBIDDEN:**
```tsx
❌ {hasIcon && <Icon />}
❌ {icon || <Fallback />}
❌ {footer && <Footer>{footer}</Footer>}
❌ icon={x ? y : z}
```

**CORRECT:**
Compute values in `props` object, reference directly in example:
```tsx
props: { 
  icon: figma.boolean('Has Icon', { 
    true: <Icon />, 
    false: undefined 
  }) 
}
example: ({ icon }) => <Button>{icon}</Button>
```

React handles `undefined` as "render nothing"—no `&&` check needed.

**Arrow function must directly return JSX:**
No function body, no statements, just the JSX expression.

## Output Format

Output **ONLY** the raw `.figma.tsx` code. No markdown fences, no explanations.

Example structure:
```tsx
import figma from '@figma/code-connect'
import { ComponentName } from './ComponentName'

export default figma.connect(ComponentName, 'figma-url', {
  props: {
    variant: figma.enum('Variant', {
      Primary: 'primary',
      Secondary: 'secondary'
    })
  },
  example: ({ variant }) => <ComponentName variant={variant} />
})
```

## Reasoning

Before generating, briefly think through:
1. What component name to query for
2. Which file(s) to read (if any)
3. How variants and properties map
4. What the import statement should be

Then output the code.


## User
## Figma Component Data

```json
{
  "componentName": "FixtureComponent",
  "variantProperties": {},
  "componentProperties": [],
  "textLayers": [],
  "slotLayers": []
}
```

## Figma URL
`https://figma.com/file/dummy-react?node-id=react-1`

## Repository Overview

- Total indexed files: 2
- Component files: 0
- Package roots: .

Use the tools to find and read the matching component file, then generate the Code Connect file.

=== AGENT OUTPUT ===

[Tool Call: queryIndex]
{
  "query": {
    "type": "exports",
    "value": "FixtureComponent"
  }
}
[Tool Result: queryIndex]
{
  "files": [],
  "total_matches": 0,
  "truncated": false
}

[Tool Call: queryIndex]
{
  "query": {
    "type": "listAll"
  }
}
[Tool Result: queryIndex]
{
  "files": [
    {
      "path": "src/App.tsx",
      "exports": [
        "App"
      ],
      "tags": [],
      "size_bytes": 87,
      "package_root": "."
    },
    {
      "path": "superconnect/spike-output.figma.tsx",
      "exports": [
        "default"
      ],
      "tags": [],
      "size_bytes": 871,
      "package_root": "."
    }
  ],
  "total_matches": 2,
  "truncated": false
}

[Tool Call: readFile]
{
  "path": "src/App.tsx"
}
[Tool Result: readFile]
{
  "path": "src/App.tsx",
  "content": "import React from 'react';\n\nexport function App() {\n  return <div>Hello React</div>;\n}\n",
  "size_bytes": 87,
  "truncated": false,
  "encoding": "utf-8",
  "cached": false
}

[Tool Call: readFile]
{
  "path": "superconnect/spike-output.figma.tsx"
}
[Tool Result: readFile]
{
  "path": "superconnect/spike-output.figma.tsx",
  "content": "Since I cannot access the repository files to find the actual FixtureComponent implementation, I'll generate a Code Connect file based on the Figma component data provided. I'll make reasonable assumptions about the component structure and import path.\n\nBased on the Figma component data, here's the Code Connect file:\n\n```tsx\nimport figma from '@figma/code-connect'\nimport { FixtureComponent } from './FixtureComponent'\n\nexport default figma.connect(FixtureComponent, 'https://figma.com/file/dummy-react?node-id=react-1', {\n  props: {\n    variant: figma.enum('variant', {\n      primary: 'primary',\n      secondary: 'secondary'\n    }),\n    label: figma.string('label'),\n    disabled: figma.boolean('disabled')\n  },\n  example: ({ variant, label, disabled }) => (\n    <FixtureComponent variant={variant} disabled={disabled}>\n      {label}\n    </FixtureComponent>\n  )\n})\n```",
  "size_bytes": 871,
  "truncated": false,
  "encoding": "utf-8",
  "cached": false
}
Based on my analysis of the repository, the FixtureComponent doesn't exist in the current codebase. The repository only contains:
1. `src/App.tsx` - with an App component
2. `superconnect/spike-output.figma.tsx` - which appears to be a previous Code Connect attempt

Since the FixtureComponent is not found in the repository, and the Figma component data shows no variant properties, component properties, text layers, or slot layers, I'll generate a minimal Code Connect file. I'll assume the component should be imported from a standard location:

```tsx
import figma from '@figma/code-connect'
import { FixtureComponent } from './FixtureComponent'

export default figma.connect(FixtureComponent, 'https://figma.com/file/dummy-react?node-id=react-1', {
  example: () => <FixtureComponent />
})
```

[Usage: in=3170 out=604 cacheWrite=0 cacheRead=9405 toolCalls=4]
